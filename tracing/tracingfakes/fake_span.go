// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"context"
	"sync"
	"time"

	"go.opentelemetry.io/otel/api/trace"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/label"
)

type FakeSpan struct {
	AddEventStub        func(context.Context, string, ...label.KeyValue)
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []label.KeyValue
	}
	AddEventWithTimestampStub        func(context.Context, time.Time, string, ...label.KeyValue)
	addEventWithTimestampMutex       sync.RWMutex
	addEventWithTimestampArgsForCall []struct {
		arg1 context.Context
		arg2 time.Time
		arg3 string
		arg4 []label.KeyValue
	}
	EndStub        func(...trace.EndOption)
	endMutex       sync.RWMutex
	endArgsForCall []struct {
		arg1 []trace.EndOption
	}
	IsRecordingStub        func() bool
	isRecordingMutex       sync.RWMutex
	isRecordingArgsForCall []struct {
	}
	isRecordingReturns struct {
		result1 bool
	}
	isRecordingReturnsOnCall map[int]struct {
		result1 bool
	}
	RecordErrorStub        func(context.Context, error, ...trace.ErrorOption)
	recordErrorMutex       sync.RWMutex
	recordErrorArgsForCall []struct {
		arg1 context.Context
		arg2 error
		arg3 []trace.ErrorOption
	}
	SetAttributeStub        func(string, interface{})
	setAttributeMutex       sync.RWMutex
	setAttributeArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	SetAttributesStub        func(...label.KeyValue)
	setAttributesMutex       sync.RWMutex
	setAttributesArgsForCall []struct {
		arg1 []label.KeyValue
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetStatusStub        func(codes.Code, string)
	setStatusMutex       sync.RWMutex
	setStatusArgsForCall []struct {
		arg1 codes.Code
		arg2 string
	}
	SpanContextStub        func() trace.SpanContext
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 trace.SpanContext
	}
	spanContextReturnsOnCall map[int]struct {
		result1 trace.SpanContext
	}
	TracerStub        func() trace.Tracer
	tracerMutex       sync.RWMutex
	tracerArgsForCall []struct {
	}
	tracerReturns struct {
		result1 trace.Tracer
	}
	tracerReturnsOnCall map[int]struct {
		result1 trace.Tracer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpan) AddEvent(arg1 context.Context, arg2 string, arg3 ...label.KeyValue) {
	fake.addEventMutex.Lock()
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []label.KeyValue
	}{arg1, arg2, arg3})
	stub := fake.AddEventStub
	fake.recordInvocation("AddEvent", []interface{}{arg1, arg2, arg3})
	fake.addEventMutex.Unlock()
	if stub != nil {
		fake.AddEventStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeSpan) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeSpan) AddEventCalls(stub func(context.Context, string, ...label.KeyValue)) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = stub
}

func (fake *FakeSpan) AddEventArgsForCall(i int) (context.Context, string, []label.KeyValue) {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	argsForCall := fake.addEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSpan) AddEventWithTimestamp(arg1 context.Context, arg2 time.Time, arg3 string, arg4 ...label.KeyValue) {
	fake.addEventWithTimestampMutex.Lock()
	fake.addEventWithTimestampArgsForCall = append(fake.addEventWithTimestampArgsForCall, struct {
		arg1 context.Context
		arg2 time.Time
		arg3 string
		arg4 []label.KeyValue
	}{arg1, arg2, arg3, arg4})
	stub := fake.AddEventWithTimestampStub
	fake.recordInvocation("AddEventWithTimestamp", []interface{}{arg1, arg2, arg3, arg4})
	fake.addEventWithTimestampMutex.Unlock()
	if stub != nil {
		fake.AddEventWithTimestampStub(arg1, arg2, arg3, arg4...)
	}
}

func (fake *FakeSpan) AddEventWithTimestampCallCount() int {
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	return len(fake.addEventWithTimestampArgsForCall)
}

func (fake *FakeSpan) AddEventWithTimestampCalls(stub func(context.Context, time.Time, string, ...label.KeyValue)) {
	fake.addEventWithTimestampMutex.Lock()
	defer fake.addEventWithTimestampMutex.Unlock()
	fake.AddEventWithTimestampStub = stub
}

func (fake *FakeSpan) AddEventWithTimestampArgsForCall(i int) (context.Context, time.Time, string, []label.KeyValue) {
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	argsForCall := fake.addEventWithTimestampArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSpan) End(arg1 ...trace.EndOption) {
	fake.endMutex.Lock()
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
		arg1 []trace.EndOption
	}{arg1})
	stub := fake.EndStub
	fake.recordInvocation("End", []interface{}{arg1})
	fake.endMutex.Unlock()
	if stub != nil {
		fake.EndStub(arg1...)
	}
}

func (fake *FakeSpan) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeSpan) EndCalls(stub func(...trace.EndOption)) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeSpan) EndArgsForCall(i int) []trace.EndOption {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	argsForCall := fake.endArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) IsRecording() bool {
	fake.isRecordingMutex.Lock()
	ret, specificReturn := fake.isRecordingReturnsOnCall[len(fake.isRecordingArgsForCall)]
	fake.isRecordingArgsForCall = append(fake.isRecordingArgsForCall, struct {
	}{})
	stub := fake.IsRecordingStub
	fakeReturns := fake.isRecordingReturns
	fake.recordInvocation("IsRecording", []interface{}{})
	fake.isRecordingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) IsRecordingCallCount() int {
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	return len(fake.isRecordingArgsForCall)
}

func (fake *FakeSpan) IsRecordingCalls(stub func() bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = stub
}

func (fake *FakeSpan) IsRecordingReturns(result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	fake.isRecordingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) IsRecordingReturnsOnCall(i int, result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	if fake.isRecordingReturnsOnCall == nil {
		fake.isRecordingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRecordingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) RecordError(arg1 context.Context, arg2 error, arg3 ...trace.ErrorOption) {
	fake.recordErrorMutex.Lock()
	fake.recordErrorArgsForCall = append(fake.recordErrorArgsForCall, struct {
		arg1 context.Context
		arg2 error
		arg3 []trace.ErrorOption
	}{arg1, arg2, arg3})
	stub := fake.RecordErrorStub
	fake.recordInvocation("RecordError", []interface{}{arg1, arg2, arg3})
	fake.recordErrorMutex.Unlock()
	if stub != nil {
		fake.RecordErrorStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeSpan) RecordErrorCallCount() int {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	return len(fake.recordErrorArgsForCall)
}

func (fake *FakeSpan) RecordErrorCalls(stub func(context.Context, error, ...trace.ErrorOption)) {
	fake.recordErrorMutex.Lock()
	defer fake.recordErrorMutex.Unlock()
	fake.RecordErrorStub = stub
}

func (fake *FakeSpan) RecordErrorArgsForCall(i int) (context.Context, error, []trace.ErrorOption) {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	argsForCall := fake.recordErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSpan) SetAttribute(arg1 string, arg2 interface{}) {
	fake.setAttributeMutex.Lock()
	fake.setAttributeArgsForCall = append(fake.setAttributeArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.SetAttributeStub
	fake.recordInvocation("SetAttribute", []interface{}{arg1, arg2})
	fake.setAttributeMutex.Unlock()
	if stub != nil {
		fake.SetAttributeStub(arg1, arg2)
	}
}

func (fake *FakeSpan) SetAttributeCallCount() int {
	fake.setAttributeMutex.RLock()
	defer fake.setAttributeMutex.RUnlock()
	return len(fake.setAttributeArgsForCall)
}

func (fake *FakeSpan) SetAttributeCalls(stub func(string, interface{})) {
	fake.setAttributeMutex.Lock()
	defer fake.setAttributeMutex.Unlock()
	fake.SetAttributeStub = stub
}

func (fake *FakeSpan) SetAttributeArgsForCall(i int) (string, interface{}) {
	fake.setAttributeMutex.RLock()
	defer fake.setAttributeMutex.RUnlock()
	argsForCall := fake.setAttributeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SetAttributes(arg1 ...label.KeyValue) {
	fake.setAttributesMutex.Lock()
	fake.setAttributesArgsForCall = append(fake.setAttributesArgsForCall, struct {
		arg1 []label.KeyValue
	}{arg1})
	stub := fake.SetAttributesStub
	fake.recordInvocation("SetAttributes", []interface{}{arg1})
	fake.setAttributesMutex.Unlock()
	if stub != nil {
		fake.SetAttributesStub(arg1...)
	}
}

func (fake *FakeSpan) SetAttributesCallCount() int {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	return len(fake.setAttributesArgsForCall)
}

func (fake *FakeSpan) SetAttributesCalls(stub func(...label.KeyValue)) {
	fake.setAttributesMutex.Lock()
	defer fake.setAttributesMutex.Unlock()
	fake.SetAttributesStub = stub
}

func (fake *FakeSpan) SetAttributesArgsForCall(i int) []label.KeyValue {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	argsForCall := fake.setAttributesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNameStub
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if stub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeSpan) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeSpan) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *FakeSpan) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetStatus(arg1 codes.Code, arg2 string) {
	fake.setStatusMutex.Lock()
	fake.setStatusArgsForCall = append(fake.setStatusArgsForCall, struct {
		arg1 codes.Code
		arg2 string
	}{arg1, arg2})
	stub := fake.SetStatusStub
	fake.recordInvocation("SetStatus", []interface{}{arg1, arg2})
	fake.setStatusMutex.Unlock()
	if stub != nil {
		fake.SetStatusStub(arg1, arg2)
	}
}

func (fake *FakeSpan) SetStatusCallCount() int {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	return len(fake.setStatusArgsForCall)
}

func (fake *FakeSpan) SetStatusCalls(stub func(codes.Code, string)) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = stub
}

func (fake *FakeSpan) SetStatusArgsForCall(i int) (codes.Code, string) {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	argsForCall := fake.setStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SpanContext() trace.SpanContext {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	stub := fake.SpanContextStub
	fakeReturns := fake.spanContextReturns
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeSpan) SpanContextCalls(stub func() trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeSpan) SpanContextReturns(result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) SpanContextReturnsOnCall(i int, result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 trace.SpanContext
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) Tracer() trace.Tracer {
	fake.tracerMutex.Lock()
	ret, specificReturn := fake.tracerReturnsOnCall[len(fake.tracerArgsForCall)]
	fake.tracerArgsForCall = append(fake.tracerArgsForCall, struct {
	}{})
	stub := fake.TracerStub
	fakeReturns := fake.tracerReturns
	fake.recordInvocation("Tracer", []interface{}{})
	fake.tracerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) TracerCallCount() int {
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	return len(fake.tracerArgsForCall)
}

func (fake *FakeSpan) TracerCalls(stub func() trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = stub
}

func (fake *FakeSpan) TracerReturns(result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	fake.tracerReturns = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) TracerReturnsOnCall(i int, result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	if fake.tracerReturnsOnCall == nil {
		fake.tracerReturnsOnCall = make(map[int]struct {
			result1 trace.Tracer
		})
	}
	fake.tracerReturnsOnCall[i] = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	fake.setAttributeMutex.RLock()
	defer fake.setAttributeMutex.RUnlock()
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpan) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ trace.Span = new(FakeSpan)
