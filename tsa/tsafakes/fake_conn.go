// Code generated by counterfeiter. DO NOT EDIT.
// Generated by running "go run github.com/maxbrunsfeld/counterfeiter/v6 "golang.org/x/crypto/ssh.Conn"

package tsafakes

import (
	"net"
	"sync"

	"golang.org/x/crypto/ssh"
)

type FakeConn struct {
	ClientVersionStub        func() []byte
	clientVersionMutex       sync.RWMutex
	clientVersionArgsForCall []struct {
	}
	clientVersionReturns struct {
		result1 []byte
	}
	clientVersionReturnsOnCall map[int]struct {
		result1 []byte
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	LocalAddrStub        func() net.Addr
	localAddrMutex       sync.RWMutex
	localAddrArgsForCall []struct {
	}
	localAddrReturns struct {
		result1 net.Addr
	}
	localAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	OpenChannelStub        func(string, []byte) (ssh.Channel, <-chan *ssh.Request, error)
	openChannelMutex       sync.RWMutex
	openChannelArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	openChannelReturns struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}
	openChannelReturnsOnCall map[int]struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}
	RemoteAddrStub        func() net.Addr
	remoteAddrMutex       sync.RWMutex
	remoteAddrArgsForCall []struct {
	}
	remoteAddrReturns struct {
		result1 net.Addr
	}
	remoteAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	SendRequestStub        func(string, bool, []byte) (bool, []byte, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 []byte
	}
	sendRequestReturns struct {
		result1 bool
		result2 []byte
		result3 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 bool
		result2 []byte
		result3 error
	}
	ServerVersionStub        func() []byte
	serverVersionMutex       sync.RWMutex
	serverVersionArgsForCall []struct {
	}
	serverVersionReturns struct {
		result1 []byte
	}
	serverVersionReturnsOnCall map[int]struct {
		result1 []byte
	}
	SessionIDStub        func() []byte
	sessionIDMutex       sync.RWMutex
	sessionIDArgsForCall []struct {
	}
	sessionIDReturns struct {
		result1 []byte
	}
	sessionIDReturnsOnCall map[int]struct {
		result1 []byte
	}
	UserStub        func() string
	userMutex       sync.RWMutex
	userArgsForCall []struct {
	}
	userReturns struct {
		result1 string
	}
	userReturnsOnCall map[int]struct {
		result1 string
	}
	WaitStub        func() error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct {
	}
	waitReturns struct {
		result1 error
	}
	waitReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConn) ClientVersion() []byte {
	fake.clientVersionMutex.Lock()
	ret, specificReturn := fake.clientVersionReturnsOnCall[len(fake.clientVersionArgsForCall)]
	fake.clientVersionArgsForCall = append(fake.clientVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("ClientVersion", []interface{}{})
	fake.clientVersionMutex.Unlock()
	if fake.ClientVersionStub != nil {
		return fake.ClientVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConn) ClientVersionCallCount() int {
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	return len(fake.clientVersionArgsForCall)
}

func (fake *FakeConn) ClientVersionCalls(stub func() []byte) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = stub
}

func (fake *FakeConn) ClientVersionReturns(result1 []byte) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = nil
	fake.clientVersionReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) ClientVersionReturnsOnCall(i int, result1 []byte) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = nil
	if fake.clientVersionReturnsOnCall == nil {
		fake.clientVersionReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.clientVersionReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeConn) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeConn) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeConn) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConn) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConn) LocalAddr() net.Addr {
	fake.localAddrMutex.Lock()
	ret, specificReturn := fake.localAddrReturnsOnCall[len(fake.localAddrArgsForCall)]
	fake.localAddrArgsForCall = append(fake.localAddrArgsForCall, struct {
	}{})
	fake.recordInvocation("LocalAddr", []interface{}{})
	fake.localAddrMutex.Unlock()
	if fake.LocalAddrStub != nil {
		return fake.LocalAddrStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localAddrReturns
	return fakeReturns.result1
}

func (fake *FakeConn) LocalAddrCallCount() int {
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	return len(fake.localAddrArgsForCall)
}

func (fake *FakeConn) LocalAddrCalls(stub func() net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = stub
}

func (fake *FakeConn) LocalAddrReturns(result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	fake.localAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConn) LocalAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	if fake.localAddrReturnsOnCall == nil {
		fake.localAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.localAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConn) OpenChannel(arg1 string, arg2 []byte) (ssh.Channel, <-chan *ssh.Request, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.openChannelMutex.Lock()
	ret, specificReturn := fake.openChannelReturnsOnCall[len(fake.openChannelArgsForCall)]
	fake.openChannelArgsForCall = append(fake.openChannelArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("OpenChannel", []interface{}{arg1, arg2Copy})
	fake.openChannelMutex.Unlock()
	if fake.OpenChannelStub != nil {
		return fake.OpenChannelStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.openChannelReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeConn) OpenChannelCallCount() int {
	fake.openChannelMutex.RLock()
	defer fake.openChannelMutex.RUnlock()
	return len(fake.openChannelArgsForCall)
}

func (fake *FakeConn) OpenChannelCalls(stub func(string, []byte) (ssh.Channel, <-chan *ssh.Request, error)) {
	fake.openChannelMutex.Lock()
	defer fake.openChannelMutex.Unlock()
	fake.OpenChannelStub = stub
}

func (fake *FakeConn) OpenChannelArgsForCall(i int) (string, []byte) {
	fake.openChannelMutex.RLock()
	defer fake.openChannelMutex.RUnlock()
	argsForCall := fake.openChannelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConn) OpenChannelReturns(result1 ssh.Channel, result2 <-chan *ssh.Request, result3 error) {
	fake.openChannelMutex.Lock()
	defer fake.openChannelMutex.Unlock()
	fake.OpenChannelStub = nil
	fake.openChannelReturns = struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConn) OpenChannelReturnsOnCall(i int, result1 ssh.Channel, result2 <-chan *ssh.Request, result3 error) {
	fake.openChannelMutex.Lock()
	defer fake.openChannelMutex.Unlock()
	fake.OpenChannelStub = nil
	if fake.openChannelReturnsOnCall == nil {
		fake.openChannelReturnsOnCall = make(map[int]struct {
			result1 ssh.Channel
			result2 <-chan *ssh.Request
			result3 error
		})
	}
	fake.openChannelReturnsOnCall[i] = struct {
		result1 ssh.Channel
		result2 <-chan *ssh.Request
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConn) RemoteAddr() net.Addr {
	fake.remoteAddrMutex.Lock()
	ret, specificReturn := fake.remoteAddrReturnsOnCall[len(fake.remoteAddrArgsForCall)]
	fake.remoteAddrArgsForCall = append(fake.remoteAddrArgsForCall, struct {
	}{})
	fake.recordInvocation("RemoteAddr", []interface{}{})
	fake.remoteAddrMutex.Unlock()
	if fake.RemoteAddrStub != nil {
		return fake.RemoteAddrStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.remoteAddrReturns
	return fakeReturns.result1
}

func (fake *FakeConn) RemoteAddrCallCount() int {
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	return len(fake.remoteAddrArgsForCall)
}

func (fake *FakeConn) RemoteAddrCalls(stub func() net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = stub
}

func (fake *FakeConn) RemoteAddrReturns(result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	fake.remoteAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConn) RemoteAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	if fake.remoteAddrReturnsOnCall == nil {
		fake.remoteAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.remoteAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeConn) SendRequest(arg1 string, arg2 bool, arg3 []byte) (bool, []byte, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("SendRequest", []interface{}{arg1, arg2, arg3Copy})
	fake.sendRequestMutex.Unlock()
	if fake.SendRequestStub != nil {
		return fake.SendRequestStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.sendRequestReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeConn) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeConn) SendRequestCalls(stub func(string, bool, []byte) (bool, []byte, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeConn) SendRequestArgsForCall(i int) (string, bool, []byte) {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeConn) SendRequestReturns(result1 bool, result2 []byte, result3 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 bool
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConn) SendRequestReturnsOnCall(i int, result1 bool, result2 []byte, result3 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 []byte
			result3 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 bool
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeConn) ServerVersion() []byte {
	fake.serverVersionMutex.Lock()
	ret, specificReturn := fake.serverVersionReturnsOnCall[len(fake.serverVersionArgsForCall)]
	fake.serverVersionArgsForCall = append(fake.serverVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("ServerVersion", []interface{}{})
	fake.serverVersionMutex.Unlock()
	if fake.ServerVersionStub != nil {
		return fake.ServerVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.serverVersionReturns
	return fakeReturns.result1
}

func (fake *FakeConn) ServerVersionCallCount() int {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	return len(fake.serverVersionArgsForCall)
}

func (fake *FakeConn) ServerVersionCalls(stub func() []byte) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = stub
}

func (fake *FakeConn) ServerVersionReturns(result1 []byte) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	fake.serverVersionReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) ServerVersionReturnsOnCall(i int, result1 []byte) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	if fake.serverVersionReturnsOnCall == nil {
		fake.serverVersionReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.serverVersionReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) SessionID() []byte {
	fake.sessionIDMutex.Lock()
	ret, specificReturn := fake.sessionIDReturnsOnCall[len(fake.sessionIDArgsForCall)]
	fake.sessionIDArgsForCall = append(fake.sessionIDArgsForCall, struct {
	}{})
	fake.recordInvocation("SessionID", []interface{}{})
	fake.sessionIDMutex.Unlock()
	if fake.SessionIDStub != nil {
		return fake.SessionIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sessionIDReturns
	return fakeReturns.result1
}

func (fake *FakeConn) SessionIDCallCount() int {
	fake.sessionIDMutex.RLock()
	defer fake.sessionIDMutex.RUnlock()
	return len(fake.sessionIDArgsForCall)
}

func (fake *FakeConn) SessionIDCalls(stub func() []byte) {
	fake.sessionIDMutex.Lock()
	defer fake.sessionIDMutex.Unlock()
	fake.SessionIDStub = stub
}

func (fake *FakeConn) SessionIDReturns(result1 []byte) {
	fake.sessionIDMutex.Lock()
	defer fake.sessionIDMutex.Unlock()
	fake.SessionIDStub = nil
	fake.sessionIDReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) SessionIDReturnsOnCall(i int, result1 []byte) {
	fake.sessionIDMutex.Lock()
	defer fake.sessionIDMutex.Unlock()
	fake.SessionIDStub = nil
	if fake.sessionIDReturnsOnCall == nil {
		fake.sessionIDReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.sessionIDReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeConn) User() string {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
	}{})
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if fake.UserStub != nil {
		return fake.UserStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.userReturns
	return fakeReturns.result1
}

func (fake *FakeConn) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeConn) UserCalls(stub func() string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeConn) UserReturns(result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConn) UserReturnsOnCall(i int, result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConn) Wait() error {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct {
	}{})
	fake.recordInvocation("Wait", []interface{}{})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitReturns
	return fakeReturns.result1
}

func (fake *FakeConn) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeConn) WaitCalls(stub func() error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = stub
}

func (fake *FakeConn) WaitReturns(result1 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConn) WaitReturnsOnCall(i int, result1 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConn) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	fake.openChannelMutex.RLock()
	defer fake.openChannelMutex.RUnlock()
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	fake.sessionIDMutex.RLock()
	defer fake.sessionIDMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConn) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ssh.Conn = new(FakeConn)
